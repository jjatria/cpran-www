
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>JJA | Smarter looping in Praat</title>
  <meta name="description" content="">
  <meta name="author" content="José Joaquín Atria">

  <!-- Enable responsive viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="/assets/themes/rodriguez/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/assets/themes/rodriguez/bootstrap/css/bs-sticky-footer.css" rel="stylesheet">

  <!-- Custom styles -->
  <link href="/assets/themes/rodriguez/css/style.css" rel="stylesheet" type="text/css" media="all">
  <link href="/assets/themes/rodriguez/css/linkbar.css" rel="stylesheet" type="text/css" media="all">
  

  <style>
    .fleuron {
      min-height: 50px;
      background: #fff url(/assets/themes/rodriguez/images/fleuron.svg) no-repeat scroll center;
      border: none;
      display: block;
    }
    .fleuron hr {
      display: none;
    }
  </style>

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
  <![endif]-->

  <!-- Fav and touch icons -->
  <link rel="shortcut icon" href="/assets/themes/rodriguez/images/favicon.ico">
  <!-- Update these with your own images
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

  <!-- atom & rss feed -->
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
  <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

</head>

<body>
<div id="wrap">
<div id="banner"><a href="/">JJA</a></div>


<link href="/assets/themes/rodriguez/css/post.css" rel="stylesheet" type="text/css" media="all">

<nav id="linkbar">
  <div id="topbar">
  <ul>
      
      
      


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
        
          <li><a href="/blog/index.html">Blog</a></li>
        
      
    
  
    
      
        
          <li><a href="/scripts/index.html">Scripts</a></li>
        
      
    
  
    
      
        
          <li><a href="/tutorials/index.html">Tutorials</a></li>
        
      
    
  
    
      
        
          <li><a href="/research/index.html">Research</a></li>
        
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  




  </ul>
  </div>
</nav>

<div class="content h-entry">

<ul class="pagination inline-list">

  <li class="prev"><a href="/2015/02/24/highlighting-praat-code-in-html" title="Highlighting Praat Code in HTML">&laquo; Previous</a></li>

  <li><a href="/archive.html">Archive</a></li>

  <li class="next disabled"><a>Next &rarr;</a>

</ul>

<div class="page-header">
  <h1 class="p-name">Smarter looping in Praat</h1> 
</div>

<div class="date">
  Posted by <a href="http://pinguinorodriguez.cl" class="p-author h-card">JJA</a> on <time class="dt-published" datetime="2015-09-11 00:00:00 +0100">11 September 2015</time>
</div>
<div class="content e-content">
  
<p>Recently, I had to make some corrections on a series of TextGrid objects I had lying around.
I needed to add a “syllable” tier with boundaries taken from a different, already existing tiers.</p>

<p>The process to make them was fairly trivial, since I knew the structure of the objects very well: the new tier (which should be the third), would be named “syllable” and would have four boundaries, each at the start of one of the even-numbered intervals in the “segment” tier (since all syllables were CV).</p>

<p>With modifications like these, I always like to work first on copies of the objects, so the changes are not final until I am confident I made no mistakes<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, and I often begin by writing the script I want assuming it will only have to work once, so that I can worry about the iteration later on.</p>

<p>My first version might look something like this:</p>

<pre class="ace praat" id="original-script"><code>Copy: extractWord$(selected$(), " ")

segment_tier = 4
new_tier = 3
syllables = 3

Insert interval tier: new_tier, "syllable"

segment_tier += 1

for i to syllables + 1
  start = Get start point: segment_tier, i*2
  Insert boundary: 3, start
  if i &lt;= syllables
    label$[1] = Get label of interval: segment_tier, i*2
    label$[2] = Get label of interval: segment_tier, 1+(i*2)
    Set interval text: 3, 1+i, label$[1] + label$[2]
  endif
endfor
</code></pre>

<p>That takes care of what I initially wanted to do, and here’s where I’d like to stop.
But <em>we’re not done here</em>, because now we need to make it loop through a number of files.
This is not difficult, but it can get tedious, specially if we want to do it right.</p>

<p>We need to</p>

<ol>
  <li>
    <p>save the object IDs into an array that I can loop over, and</p>
  </li>
  <li>
    <p>make sure we restore the final selection of newly created objects at the end</p>
  </li>
</ol>

<p>Since Praat doesn’t have any knowledge of selections, all this has to be done by hand<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>.
The new code, with boilerplate added, would be like this:</p>

<pre class="ace praat"><code>total_textgrids = numberOfSelected("TextGrid")
for i to total_textgrids
  textgrid[i] = selected(i)
endfor

for i to total_textgrids
  selectObject: textgrid[i]

  new[i] = Copy: extractWord$(selected$(), " ")
  # Include the rest of the example above

endfor

nocheck selectObject: undefined
for i to total_textgrids
  plusObject: new[i]
endfor
</code></pre>

<p>Note that we also had to change the first line of the original snippet, so that now we keep track of what object was created to select it at the end.</p>

<p>That boilerplate works fine, but it also requires that all objects be open in the Object window, which when dealing with large number of files can be troublesome.
The alternative would be to change it to use a Strings objects holding the paths to the file names we want, so objects can be read one at a time.</p>

<p>In that case, the script would look like this:</p>

<pre class="ace praat"><code>file_list = selected("Strings")
total_strings = Get total strings
for i to strings
  selectObject: file_list
  file_name$ = Get string: i
  source = Read from file: base_path$ + file_name$

  new[i] = Copy: extractWord$(selected$(), " ")
  # Include the rest of the example above

  removeObject: source
endfor

# Include the selection-restoration here
</code></pre>

<p>And this is when things start to get messy, because both of these solutions work well… as long as this is exactly what we want to do.
This boilerplate we’ve added only works in this scenario: when we are looping through a series of objects, selecting one at a time, and generating a single new file for each.</p>

<p>But what if we wanted to loop over <em>combinations</em> of objects?
And what if for each of those combinations we wanted to create a number of different objects?
This might sound like a far-fetched example, but this is exactly what happens when you want to extract intervals in a Sound object using a TextGrid annotation.
And even if Praat has internal commands to do that, I think it’s clear that it’s not hard to think of scenarios where the boilerplate can get really annoying, really quickly.</p>

<p>Programmers can sometimes sound a bit lazy with all their attempts at automatising tasks.
But in fact, laziness is one of the <a href="http://threevirtues.com/">three great virtues of a programmer</a>.
It’s what makes us “write labour-saving programs that others will find useful”.
Which is exactly what I did.</p>

<h2 id="lets-get-lazier">Let’s get lazier</h2>

<p>Enter <a href="https://gitlab.com/cpran/plugin_vieweach"><strong>vieweach</strong></a>, a CPrAN plugin for Praat, whose main objective is to implement versatile and customisable object looping routines.
<strong>vieweach</strong> has many applications, because its objective is to try to cover <em>all</em> the cases in which we might want to iterate over objects, and it tries to cover that by exposing an interface that is customisable and extensible, so that—to borrow from the Llama book—<a href="http://news.oreilly.com/2008/07/making-easy-things-easy-hard-t.html">easy things are easy, and hard things are possible</a>.</p>

<p>One of the things that are made easy by <strong>vieweach</strong> is precisely what we’ve been trying to do.
By saving <a href="#original-script">that original script</a> to disk (a current requirement that hopefully will get lifted in the future), we can replace the entire script with boilerplate included by this:</p>

<pre class="ace praat"><code>runScript: preferencesDirectory$ + "/plugin_vieweach/scripts/" +
  ... "for_each.praat", "my_script.praat", "Don't bundle"
</code></pre>

<p>That’s it.</p>

<p>Really.</p>

<p>That does everything we talked about above: it loops through all selected objects, runs the script for each, and if at the end of the script the selection has changed, then those new objects are selected automatically at the end.</p>

<p>And if the selection contained TextGrid and Pitch objects, and the script needed to be run with one of each each time?
Easy:</p>

<pre class="ace praat"><code>runScript: preferencesDirectory$ + "/plugin_vieweach/scripts/" +
  ... "for_each.praat", "my_script.praat", "Per type"
</code></pre>

<h2 id="bundling">Bundling</h2>

<p>The difference between the two commands above is the type of bundling that the iterator is using.</p>

<p>In the first case, it does no bundling, and it simply iterates through each of the selected objects from the first to the last, regardless of what objects they are.</p>

<p>The second line does something similar, but slightly more sophisticated: it also works with the selected objects, but it separates them by object type, and then iterates through combinations of one object of each type.
So if the selection had Sound and TextGrid objects, one of each will be selected each time the iterator runs.</p>

<p>What happens if they are not the same number?
Then the shorter list of objects loops over, and the iterator still runs once for each item in the longest list.
This means that I can use the same process if I want to operate on a number of objects, each of them in combination to a single other.</p>

<p>But what if I want to combine the two, to iterate over sets in which some objects are in disk and some objects are in the Object window?
In that case we need to use the third bundling option, which wasn’t shown here: “Use sets”.</p>

<p><strong>vieweach</strong> uses another CPrAN plugin called <a href="http://gitlab.com/cpran/plugin_selection"><strong>selection</strong></a> for all its selection management and bundling.
I won’t go into the details of what <strong>selection</strong> does (I’ll leave that for another post), but one of the things it does is define “sets” of objects that can reside either in disk or in the Object window.</p>

<p>Sets in disk are represented by Strings objects, much like it’s done traditionally in Praat (although using full paths instead of just the file names), and sets in memory are represented by what are called “<a href="https://gitlab.com/cpran/plugin_selection#overview">selection tables</a>”, which exists in Praat as a Table object which holds the objects’ name, type, ID number, etc.</p>

<aside class="rem">
  <p>In fact, when you select a “per type” bundling, what Praat is doing is generating as many “selection tables” as object types are in the current selection.</p>
</aside>

<p>So all you’d have to do to combine these two is to make a Strings object for your objects in disk, and a Table object for your objects in the Object window, select them, and run the script again telling it to assume that each selected object represents <em>a set</em> of objects, and use those for bundling.</p>

<aside class="rem">
  <p>The <strong>selection</strong> plugin has commands to easily create selection tables out of existing selections, which can be combined or manipulated. To generate the needed Strings objects with full paths, you can do it by hand… or use yet another CPrAN plugin: “<a href="https://gitlab.com/cpran/plugin_strutils"><strong>strutils</strong></a>”.</p>
</aside>

<p>This is just a taster of the kinds of things that can be done with <strong>vieweach</strong> and the rest of the plugins in CPrAN.</p>

<p><a href="http://cpran.net">Get involved!</a> And stay tuned for more.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Confession: I make <em>lots</em> of mistakes… <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Actually, we don’t: a plugin in CPrAN called … “<a href="http://gitlab.com/cpran/plugin_selection"><strong>selection</strong></a>” deals with precisely this problem, and makes it possible to do all sorts of funky stuff with object selections. But let’s not get ahead of ourselves… <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>




<ul class="tag_box inline-list">
  
  


  
     
    	<li class="tag"><a href="/tags.html#praat" rel="tag">praat <span>3</span></a></li>
     
    	<li class="tag"><a href="/tags.html#cpran" rel="tag">cpran <span>1</span></a></li>
     
    	<li class="tag"><a href="/tags.html#vieweach" rel="tag">vieweach <span>1</span></a></li>
     
    	<li class="tag"><a href="/tags.html#selection" rel="tag">selection <span>1</span></a></li>
     
    	<li class="tag"><a href="/tags.html#strutils" rel="tag">strutils <span>1</span></a></li>
     
    	<li class="tag"><a href="/tags.html#tutorial" rel="tag">tutorial <span>3</span></a></li>
    
  



</ul>


<ul class="pagination inline-list">

  <li class="prev"><a href="/2015/02/24/highlighting-praat-code-in-html" title="Highlighting Praat Code in HTML">&laquo; Previous</a></li>

  <li><a href="/archive.html">Archive</a></li>

  <li class="next disabled"><a>Next &rarr;</a>

</ul>


</div>



<div class='fleuron'><hr /></div>

</div>

  <div id="footer">
    <div class="container">
      <p>&copy; 2015 JJA |
        Built with <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
      </p>
    </div>
  </div>

  




  <!-- Latest compiled and minified JavaScript, requires jQuery 1.x (2.x not supported in IE8) -->
  <!-- Placed at the end of the document so the pages load faster -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="/assets/themes/rodriguez/bootstrap/js/bootstrap.min.js"></script>
  
    
  <script src="/assets/themes/rodriguez/../../lib/ace/ace.js"></script>
  <script src="/assets/themes/rodriguez/../../lib/ace/mode-praat.js"></script>
  <script src="/assets/themes/rodriguez/../../lib/ace/theme-solarized_light.js"></script>
  <script>
      function qsa(sel) {
          return Array.apply(null, document.querySelectorAll(sel));
      }

      qsa(".ace").forEach(function (codeEl) {
          var classes = codeEl.className;
          classes = classes.split(" ");
          var mode = "praat";
          var readonly = true;
          classes.forEach(function (e, i, a) {
            if (e == "praat" ||
                e == "javascript" ||
                e == "yaml" ||
                e == "latex" ||
                e == "tex" ||
                e == "html" ||
                e == "css" ||
                e == "perl") { mode = e };
            if (e == "editable") { readonly = false };
          });

          ace.edit(codeEl).setOptions({
              maxLines: 20,
              readOnly: readonly,
              autoScrollEditorIntoView: true,
              mode:  "ace/mode/" + mode,
              theme: "ace/theme/solarized_light",
              firstLineNumber: parseInt(codeEl.getAttribute("data-start") || 1),
              showGutter: true,
          });
      });
  </script>
    
  
</body>
</html>

