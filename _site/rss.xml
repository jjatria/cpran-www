<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>JJA</title>
        <description>JJA - José Joaquín Atria</description>
        <link>http://jjatria.github.io</link>
        <atom:link href="http://jjatria.github.io/rss.xml" rel="self" type="application/rss+xml" />
        <lastBuildDate>Fri, 09 Oct 2015 18:27:17 +0100</lastBuildDate>
        <pubDate>Fri, 09 Oct 2015 18:27:17 +0100</pubDate>
        <ttl>60</ttl>


        <item>
                <title>Smarter looping in Praat</title>
                <description>
&lt;p&gt;Recently, I had to make some corrections on a series of TextGrid objects I had lying around.
I needed to add a “syllable” tier with boundaries taken from a different, already existing tiers.&lt;/p&gt;

&lt;p&gt;The process to make them was fairly trivial, since I knew the structure of the objects very well: the new tier (which should be the third), would be named “syllable” and would have four boundaries, each at the start of one of the even-numbered intervals in the “segment” tier (since all syllables were CV).&lt;/p&gt;

&lt;p&gt;With modifications like these, I always like to work first on copies of the objects, so the changes are not final until I am confident I made no mistakes&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, and I often begin by writing the script I want assuming it will only have to work once, so that I can worry about the iteration later on.&lt;/p&gt;

&lt;p&gt;My first version might look something like this:&lt;/p&gt;

&lt;pre class=&quot;ace praat&quot; id=&quot;original-script&quot;&gt;&lt;code&gt;Copy: extractWord$(selected$(), &quot; &quot;)

segment_tier = 4
new_tier = 3
syllables = 3

Insert interval tier: new_tier, &quot;syllable&quot;

segment_tier += 1

for i to syllables + 1
  start = Get start point: segment_tier, i*2
  Insert boundary: 3, start
  if i &amp;lt;= syllables
    label$[1] = Get label of interval: segment_tier, i*2
    label$[2] = Get label of interval: segment_tier, 1+(i*2)
    Set interval text: 3, 1+i, label$[1] + label$[2]
  endif
endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That takes care of what I initially wanted to do, and here’s where I’d like to stop.
But &lt;em&gt;we’re not done here&lt;/em&gt;, because now we need to make it loop through a number of files.
This is not difficult, but it can get tedious, specially if we want to do it right.&lt;/p&gt;

&lt;p&gt;We need to&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;save the object IDs into an array that I can loop over, and&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;make sure we restore the final selection of newly created objects at the end&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Since Praat doesn’t have any knowledge of selections, all this has to be done by hand&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.
The new code, with boilerplate added, would be like this:&lt;/p&gt;

&lt;pre class=&quot;ace praat&quot;&gt;&lt;code&gt;total_textgrids = numberOfSelected(&quot;TextGrid&quot;)
for i to total_textgrids
  textgrid[i] = selected(i)
endfor

for i to total_textgrids
  selectObject: textgrid[i]

  new[i] = Copy: extractWord$(selected$(), &quot; &quot;)
  # Include the rest of the example above

endfor

nocheck selectObject: undefined
for i to total_textgrids
  plusObject: new[i]
endfor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we also had to change the first line of the original snippet, so that now we keep track of what object was created to select it at the end.&lt;/p&gt;

&lt;p&gt;That boilerplate works fine, but it also requires that all objects be open in the Object window, which when dealing with large number of files can be troublesome.
The alternative would be to change it to use a Strings objects holding the paths to the file names we want, so objects can be read one at a time.&lt;/p&gt;

&lt;p&gt;In that case, the script would look like this:&lt;/p&gt;

&lt;pre class=&quot;ace praat&quot;&gt;&lt;code&gt;file_list = selected(&quot;Strings&quot;)
total_strings = Get total strings
for i to strings
  selectObject: file_list
  file_name$ = Get string: i
  source = Read from file: base_path$ + file_name$

  new[i] = Copy: extractWord$(selected$(), &quot; &quot;)
  # Include the rest of the example above

  removeObject: source
endfor

# Include the selection-restoration here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is when things start to get messy, because both of these solutions work well… as long as this is exactly what we want to do.
This boilerplate we’ve added only works in this scenario: when we are looping through a series of objects, selecting one at a time, and generating a single new file for each.&lt;/p&gt;

&lt;p&gt;But what if we wanted to loop over &lt;em&gt;combinations&lt;/em&gt; of objects?
And what if for each of those combinations we wanted to create a number of different objects?
This might sound like a far-fetched example, but this is exactly what happens when you want to extract intervals in a Sound object using a TextGrid annotation.
And even if Praat has internal commands to do that, I think it’s clear that it’s not hard to think of scenarios where the boilerplate can get really annoying, really quickly.&lt;/p&gt;

&lt;p&gt;Programmers can sometimes sound a bit lazy with all their attempts at automatising tasks.
But in fact, laziness is one of the &lt;a href=&quot;http://threevirtues.com/&quot;&gt;three great virtues of a programmer&lt;/a&gt;.
It’s what makes us “write labour-saving programs that others will find useful”.
Which is exactly what I did.&lt;/p&gt;

&lt;h2 id=&quot;lets-get-lazier&quot;&gt;Let’s get lazier&lt;/h2&gt;

&lt;p&gt;Enter &lt;a href=&quot;https://gitlab.com/cpran/plugin_vieweach&quot;&gt;&lt;strong&gt;vieweach&lt;/strong&gt;&lt;/a&gt;, a CPrAN plugin for Praat, whose main objective is to implement versatile and customisable object looping routines.
&lt;strong&gt;vieweach&lt;/strong&gt; has many applications, because its objective is to try to cover &lt;em&gt;all&lt;/em&gt; the cases in which we might want to iterate over objects, and it tries to cover that by exposing an interface that is customisable and extensible, so that—to borrow from the Llama book—&lt;a href=&quot;http://news.oreilly.com/2008/07/making-easy-things-easy-hard-t.html&quot;&gt;easy things are easy, and hard things are possible&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the things that are made easy by &lt;strong&gt;vieweach&lt;/strong&gt; is precisely what we’ve been trying to do.
By saving &lt;a href=&quot;#original-script&quot;&gt;that original script&lt;/a&gt; to disk (a current requirement that hopefully will get lifted in the future), we can replace the entire script with boilerplate included by this:&lt;/p&gt;

&lt;pre class=&quot;ace praat&quot;&gt;&lt;code&gt;runScript: preferencesDirectory$ + &quot;/plugin_vieweach/scripts/&quot; +
  ... &quot;for_each.praat&quot;, &quot;my_script.praat&quot;, &quot;Don&#39;t bundle&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s it.&lt;/p&gt;

&lt;p&gt;Really.&lt;/p&gt;

&lt;p&gt;That does everything we talked about above: it loops through all selected objects, runs the script for each, and if at the end of the script the selection has changed, then those new objects are selected automatically at the end.&lt;/p&gt;

&lt;p&gt;And if the selection contained TextGrid and Pitch objects, and the script needed to be run with one of each each time?
Easy:&lt;/p&gt;

&lt;pre class=&quot;ace praat&quot;&gt;&lt;code&gt;runScript: preferencesDirectory$ + &quot;/plugin_vieweach/scripts/&quot; +
  ... &quot;for_each.praat&quot;, &quot;my_script.praat&quot;, &quot;Per type&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bundling&quot;&gt;Bundling&lt;/h2&gt;

&lt;p&gt;The difference between the two commands above is the type of bundling that the iterator is using.&lt;/p&gt;

&lt;p&gt;In the first case, it does no bundling, and it simply iterates through each of the selected objects from the first to the last, regardless of what objects they are.&lt;/p&gt;

&lt;p&gt;The second line does something similar, but slightly more sophisticated: it also works with the selected objects, but it separates them by object type, and then iterates through combinations of one object of each type.
So if the selection had Sound and TextGrid objects, one of each will be selected each time the iterator runs.&lt;/p&gt;

&lt;p&gt;What happens if they are not the same number?
Then the shorter list of objects loops over, and the iterator still runs once for each item in the longest list.
This means that I can use the same process if I want to operate on a number of objects, each of them in combination to a single other.&lt;/p&gt;

&lt;p&gt;But what if I want to combine the two, to iterate over sets in which some objects are in disk and some objects are in the Object window?
In that case we need to use the third bundling option, which wasn’t shown here: “Use sets”.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;vieweach&lt;/strong&gt; uses another CPrAN plugin called &lt;a href=&quot;http://gitlab.com/cpran/plugin_selection&quot;&gt;&lt;strong&gt;selection&lt;/strong&gt;&lt;/a&gt; for all its selection management and bundling.
I won’t go into the details of what &lt;strong&gt;selection&lt;/strong&gt; does (I’ll leave that for another post), but one of the things it does is define “sets” of objects that can reside either in disk or in the Object window.&lt;/p&gt;

&lt;p&gt;Sets in disk are represented by Strings objects, much like it’s done traditionally in Praat (although using full paths instead of just the file names), and sets in memory are represented by what are called “&lt;a href=&quot;https://gitlab.com/cpran/plugin_selection#overview&quot;&gt;selection tables&lt;/a&gt;”, which exists in Praat as a Table object which holds the objects’ name, type, ID number, etc.&lt;/p&gt;

&lt;aside class=&quot;rem&quot;&gt;
  &lt;p&gt;In fact, when you select a “per type” bundling, what Praat is doing is generating as many “selection tables” as object types are in the current selection.&lt;/p&gt;
&lt;/aside&gt;

&lt;p&gt;So all you’d have to do to combine these two is to make a Strings object for your objects in disk, and a Table object for your objects in the Object window, select them, and run the script again telling it to assume that each selected object represents &lt;em&gt;a set&lt;/em&gt; of objects, and use those for bundling.&lt;/p&gt;

&lt;aside class=&quot;rem&quot;&gt;
  &lt;p&gt;The &lt;strong&gt;selection&lt;/strong&gt; plugin has commands to easily create selection tables out of existing selections, which can be combined or manipulated. To generate the needed Strings objects with full paths, you can do it by hand… or use yet another CPrAN plugin: “&lt;a href=&quot;https://gitlab.com/cpran/plugin_strutils&quot;&gt;&lt;strong&gt;strutils&lt;/strong&gt;&lt;/a&gt;”.&lt;/p&gt;
&lt;/aside&gt;

&lt;p&gt;This is just a taster of the kinds of things that can be done with &lt;strong&gt;vieweach&lt;/strong&gt; and the rest of the plugins in CPrAN.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cpran.net&quot;&gt;Get involved!&lt;/a&gt; And stay tuned for more.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Confession: I make &lt;em&gt;lots&lt;/em&gt; of mistakes… &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Actually, we don’t: a plugin in CPrAN called … “&lt;a href=&quot;http://gitlab.com/cpran/plugin_selection&quot;&gt;&lt;strong&gt;selection&lt;/strong&gt;&lt;/a&gt;” deals with precisely this problem, and makes it possible to do all sorts of funky stuff with object selections. But let’s not get ahead of ourselves… &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://jjatria.github.io/2015/09/11/smarter-looping-in-praat</link>
                <guid>http://jjatria.github.io/2015/09/11/smarter-looping-in-praat</guid>
                <pubDate>Fri, 11 Sep 2015 00:00:00 +0100</pubDate>
        </item>

        <item>
                <title>Highlighting Praat Code in HTML</title>
                <description>
&lt;p&gt;This page uses &lt;a href=&quot;http://ace.c9.io/&quot;&gt;ace&lt;/a&gt; to dynamically highlight Praat code. All highlighting is
done through the ace editor, which means that the source of this page just
contains pure Praat code.&lt;/p&gt;

&lt;p&gt;Here’s a snippet:&lt;/p&gt;

&lt;pre class=&quot;ace praat editable&quot;&gt;&lt;code&gt;form Highlighter test
  sentence My_sentence This should all be a string
  text My_text This should also all be a string
  word My_word Only the first word is a string, the rest is invalid
  boolean Binary 1
  boolean Quoted &quot;yes&quot;
  comment This should be a string
  real left_Range -123.6
  positive right_Range_max 3.3
  integer Int 4
  natural Nat 4
endform
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This paragraph is between the code, to maybe illustrate a specific part of the
script. The code can then resume from where we left off by specifying the start
line number, in this case using the &lt;code&gt;data-start&lt;/code&gt; attribute.&lt;/p&gt;

&lt;pre class=&quot;ace praat editable&quot; data-start=&quot;14&quot;&gt;&lt;code&gt;# External scripts
include /path/to/file
runScript: &quot;/path/to/file&quot;
execute /path/to/file

stopwatch

# old-style procedure call
call oldStyle &quot;quoted&quot; 2 unquoted string
assert oldStyle.local = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here is a much longer snippet of code, to show automatic scrolling.&lt;/p&gt;

&lt;pre class=&quot;ace praat editable&quot; data-start=&quot;25&quot;&gt;&lt;code&gt;# New-style procedure call with parens
@newStyle(&quot;quoted&quot;, 2, &quot;quoted string&quot;)
if praatVersion &amp;gt;= 5364
  # New-style procedure call with colon
  @newStyle: &quot;quoted&quot;, 2, &quot;quoted string&quot;
endif

# if-block with built-in variables
if windows
  # We are on Windows
elsif unix = 1 or !macintosh
  exitScript: &quot;We are on Linux&quot;
else
  # macintosh == 1
  exit We are on Mac
endif

# inline if with inline comment
var = if macintosh = 1 then 0 else 1 fi ; This is an inline comment

# for-loop with explicit from using local variable
# and paren-style function calls and variable interpolation
n = numberOfSelected(&quot;Sound&quot;)
for i from newStyle.local to n
  sound&#39;i&#39; = selected(&quot;Sound&quot;, i)
  sound[i] = sound&#39;i&#39;
endfor

for i from 1 to n
  # Different styles of object selection
  select sound&#39;i&#39;
  sound = selected()
  sound$ = selected$(&quot;Sound&quot;)
  select Sound &#39;sound$&#39;
  selectObject(sound[i])
  selectObject: sound

  # New-style standalone command call
  Rename: &quot;SomeName&quot;

  # Command call with assignment
  duration = Get total duration

  # Multi-line command with modifier
  pitch = noprogress To Pitch (ac): 0, 75, 15, &quot;no&quot;,
    ...0.03, 0.45, 0.01, 0.35, 0.14, 600

  # do-style command with assignment
  minimum = do(&quot;Get minimum...&quot;, 0, 0, &quot;Hertz&quot;, &quot;Parabolic&quot;)

  # New-style multi-line command call with broken strings
  table = Create Table with column names: &quot;table&quot;, 0,
    ...&quot;file subject speaker
    ...f0 f1 f2 f3 &quot; +
    ...&quot;duration response&quot;

  removeObject: pitch, table

  # Picture window commands
  selectObject: sound
  # do-style command
  do(&quot;Select inner viewport...&quot;, 1, 6, 0.5, 1.5)
  Black
  Draw... 0 0 0 0 &quot;no&quot; Curve
  Draw inner box
  Text bottom: &quot;yes&quot;, sound$
  Erase all

  # Demo window commands
  demo Erase all
  demo Select inner viewport... 0 100 0 100
  demo Axes... 0 100 0 100
  demo Paint rectangle... white 0 100 0 100
  demo Text... 50 centre 50 half Click to finish
  demoWaitForInput ( )
  demo Erase all
  demo Text: 50, &quot;centre&quot;, 50, &quot;half&quot;, &quot;Finished&quot;
endfor

# An old-style sendpraat block
sendpraat Praat
  ...&#39;newline$&#39; Create Sound as pure tone... &quot;tone&quot; 1 0 0.4 44100 440 0.2 0.01 0.01
  ...&#39;newline$&#39; Play
  ...&#39;newline$&#39; Remove

# A new-style sendpraat block
beginSendPraat: &quot;Praat&quot;
  Create Sound as pure tone: &quot;tone&quot;, 1, 0, 0.4, 44100, 440, 0.2, 0.01, 0.01
  duration = Get total duration
  Remove
endSendPraat: &quot;duration&quot;
appendInfoLine: &quot;The generated sound lasted for &quot;, duration, &quot;seconds&quot;

time = stopwatch
clearinfo
echo This script took
print &#39;time&#39; seconds to
printline execute.

# Old-style procedure declaration
procedure oldStyle .str1$ .num .str2$
  .local = 1
endproc

# New-style procedure declaration
procedure newStyle (.str1$, .num, .str2$)
  .local = 1
endproc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way: &lt;a href=&quot;http://ace.c9.io/&quot;&gt;ace&lt;/a&gt; is a text &lt;em&gt;editor&lt;/em&gt;, and all the highlighted snippets are
instances of that editor. This means that all those fields are
&lt;a href=&quot;images/mind_blown.gif&quot;&gt;&lt;em&gt;editable&lt;/em&gt;&lt;/a&gt;. Go on. Try.&lt;/p&gt;

&lt;p&gt;Praat is available as an ace language mode starting from ace 1.1.6. Other
available editor highlighters are listed below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jjatria/praatKateSyntax&quot;&gt;Kate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sadowsky.cl/praat.html#syntax&quot;&gt;Notepad++&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mauriciofigueroa/praatSublimeSyntax&quot;&gt;SublimeText&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dopefishh/vim-praat&quot;&gt;vim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://jjatria.github.io/2015/02/24/highlighting-praat-code-in-html</link>
                <guid>http://jjatria.github.io/2015/02/24/highlighting-praat-code-in-html</guid>
                <pubDate>Tue, 24 Feb 2015 00:00:00 +0000</pubDate>
        </item>

        <item>
                <title>Continuum synthesis with TandemSTRAIGHT</title>
                <description>
&lt;style&gt;
  #ui { text-align:center; display: table; width: 100%; }
  #row { display: table-row; }
  #ui input[type=&quot;checkbox&quot;]:checked + label { font-weight: bold; }
  #row div { display: table-cell; }
  #buttons { text-align: left; }
  #row #buttons div { display: inline-block; width: 4em; }
  #dropdown { text-align: right; }
  #spectrogram {
    width: 100%;
    border: 2px black solid;
  }
  #straight h2 {
    text-align: center;
    padding: 0;
    line-height: 1.5em;
  }
  #straight { padding-bottom: 3em; }
&lt;/style&gt;

&lt;p&gt;TandemSTRAIGHT is a set of Matlab scripts for analysis and manipulation of
speech, and you can read more about it
on &lt;a href=&quot;http://www.wakayama-u.ac.jp/~kawahara/STRAIGHTadv/index_e.html&quot;&gt;the TandemSTRAIGHT website&lt;/a&gt;. These are the results of some
basic tests I’ve made for myself, using two different sounds and transplanting
the different acoustic parameters in STRAIGHT from one to the other.&lt;/p&gt;

&lt;p&gt;You can choose the base and target sounds from the drop-down menu (although so
far there’s only two sound pairs) and select the features you want copied to see
the spectrogram of the synthesised sound. If you click on the spectrogram, you
can also hear how it sounds.&lt;/p&gt;

&lt;noscript&gt;
  &lt;aside class=&quot;rem&quot;&gt;

    &lt;p&gt;The demo widget on this page requires JavaScript to work, and your browser
does not seem to be able to run JavaScript right now. Until I come up with a
solution, this sadly means you won’t be able to use the demo.&lt;/p&gt;

  &lt;/aside&gt;
&lt;/noscript&gt;

&lt;div id=&quot;straight&quot;&gt;

&lt;h2 id=&quot;straight-header&quot;&gt;&lt;/h2&gt;

&lt;div id=&quot;basediv&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;synthdiv&quot;&gt;
  &lt;a id=&quot;synthlink&quot; class=&quot;inline-playable&quot;&gt;
    &lt;img id=&quot;spectrogram&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;
&lt;div id=&quot;targetdiv&quot;&gt;&lt;/div&gt;

&lt;div id=&quot;ui&quot;&gt;
  &lt;div id=&quot;row&quot;&gt;
  &lt;div id=&quot;buttons&quot;&gt;
  &lt;div&gt;
    &lt;input id=&quot;freq&quot; name=&quot;freq&quot; type=&quot;checkbox&quot; value=&quot;16&quot; onchange=&quot;getFlags(this)&quot; /&gt;
    &lt;label for=&quot;freq&quot; title=&quot;Frequency level?&quot;&gt;Freq&lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input id=&quot;spec&quot; name=&quot;spec&quot; type=&quot;checkbox&quot; value=&quot;8&quot; onchange=&quot;getFlags(this)&quot; /&gt;
    &lt;label for=&quot;spec&quot; title=&quot;Not sure...&quot;&gt;Spec&lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input id=&quot;ap&quot; name=&quot;ap&quot; type=&quot;checkbox&quot; value=&quot;4&quot; onchange=&quot;getFlags(this)&quot; /&gt;
    &lt;label for=&quot;ap&quot; title=&quot;Aperiodicity&quot;&gt;AP&lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input id=&quot;f0&quot; name=&quot;f0&quot; type=&quot;checkbox&quot; value=&quot;2&quot; onchange=&quot;getFlags(this)&quot; /&gt;
    &lt;label for=&quot;f0&quot; title=&quot;Fundamental frequency&quot;&gt;F0&lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input id=&quot;time&quot; name=&quot;time&quot; type=&quot;checkbox&quot; value=&quot;1&quot; onchange=&quot;getFlags(this)&quot; /&gt;
    &lt;label for=&quot;time&quot;&gt;Time&lt;/label&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=&quot;dropdown&quot;&gt;
  &lt;select onchange=&quot;getRoot(this)&quot;&gt;
    &lt;option value=&quot;l1-l2&quot;&gt;Spanish; first to second&lt;/option&gt;
    &lt;option value=&quot;km1-km2&quot;&gt;Japanese; first to second&lt;/option&gt;
  &lt;/select&gt;
  &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  var flag = 0;
  var root = &#39;l1-l2&#39;;
  window.onload = function() { update(root, flag) };
  function getFlags(btn) {
    flag = flag ^ btn.value;
    update(root, flag);
  }
  function getRoot(sel) {
    root = sel.options[sel.selectedIndex].value;
    update(root, flag);
  }
  function update(r, f) {
    // Takes the file root and set of flags and sets properties
    // in the appropriate image and link
    i = document.getElementById(&#39;spectrogram&#39;);
    a = document.getElementById(&#39;synthlink&#39;);
    var n = (&quot;0000&quot; + f.toString(2)).substr(-5);
    i.setAttribute(&#39;src&#39;, &#39;/assets/tutorials/straight_continuum/figures/&#39;+r+&#39;.&#39;+n+&#39;.png&#39;);
    a.setAttribute(&#39;href&#39;, &#39;/assets/tutorials/straight_continuum/audio/&#39;+r+&#39;.&#39;+n+&#39;.mp3&#39;);
    setTitle(root);
  }
  function setTitle(r) {
    var h = document.getElementById(&#39;straight-header&#39;);
    switch (r) {
    case &#39;l1-l2&#39;:
      h.innerHTML = &quot;límite ~ limíte&quot;;
      break;
    case &#39;km1-km2&#39;:
      h.innerHTML = &quot;&lt;div class=&#39;jaccent&#39;&gt;&lt;span class=&#39;F&#39;&gt;ka&lt;/span&gt;&lt;span class=&#39;L&#39;&gt;mimo&lt;/span&gt; ~ &lt;span class=&#39;R&#39;&gt;ka&lt;/span&gt;&lt;span class=&#39;F&#39;&gt;mi&lt;/span&gt;&lt;span class=&#39;L&#39;&gt;mo&lt;/span&gt;&lt;/div&gt;&quot;;
      break;
    }
  }
&lt;/script&gt;
&lt;/div&gt;
</description>
                <link>http://jjatria.github.io/2013/06/20/continuum-synthesis-with-tandemstraight</link>
                <guid>http://jjatria.github.io/2013/06/20/continuum-synthesis-with-tandemstraight</guid>
                <pubDate>Thu, 20 Jun 2013 00:00:00 +0100</pubDate>
        </item>

        <item>
                <title>Pitch in Praat</title>
                <description>
&lt;aside class=&quot;rem&quot;&gt;
  &lt;p&gt;This page uses SVG files for the figures, so that they don’t lose detail when
being resized. If your browser does not support SVG files, a PNG file should be
available as a fallback. If you have any trouble viewing the figures, I would
appreciate if you could drop me a line.&lt;/p&gt;
&lt;/aside&gt;

&lt;p&gt;The analysis of periodic curves is best suited when working with continuous,
stable curves. However, the sounds of speech are nothing if not unstable, which
makes analysis more difficult. Praat overcomes this by assuming that speech is
sufficiently stable when looking at small enough fragments of it, which are
called  ‘windows of analysis’.&lt;/p&gt;

&lt;p&gt;This is the sound we’ll be working on: a complex sound wave with a fundamental
frequency of 140Hz and a harmonic of 280Hz.&lt;/p&gt;

&lt;figure&gt;
 &lt;figcaption&gt;The sound in the analysis window&lt;/figcaption&gt;
 &lt;object data=&quot;/assets/tutorials/praat_pitch/figures/fig1.svg&quot;&gt;
  &lt;img src=&quot;/assets/tutorials/praat_pitch/figures/fig1.png&quot; alt=&quot;Three cycles of a complex sine wave, with a peak amplitude of 1 and
  starting and ending at 0. The horizontal axis is 945 samples long&quot; /&gt;
 &lt;/object&gt;
&lt;/figure&gt;

&lt;p&gt;Each window is filtered to make sure there are no intensity peaks on the edges,
which facilitates analysis. The filter used in this demonstration is a Hanning
window (&lt;a href=&quot;#boersma1993&quot;&gt;Boersma, 1993&lt;/a&gt;). According to the
Praat documentation, a Hanning window is more responsive when working with 3
periods per analysis window, while a Gaussian window is better when working with
a larger analysis window (the Gaussian window is twice as large as the Hanning
window).&lt;/p&gt;

&lt;p&gt;Praat indeed uses both these windows as default depending on the task and the
degree of precision that is required.&lt;/p&gt;

&lt;figure&gt;
 &lt;figcaption&gt;The Hanning filter function&lt;/figcaption&gt;
 &lt;object data=&quot;/assets/tutorials/praat_pitch/figures/fig2.svg&quot;&gt;
  &lt;img src=&quot;/assets/tutorials/praat_pitch/figures/fig2.png&quot; alt=&quot;A Hanning filter, tracing a bell curve asymptotically approaching 0 on
  both ends&quot; /&gt;
 &lt;/object&gt;
&lt;/figure&gt;

&lt;p&gt;We apply the filter by multiplying both curves.&lt;/p&gt;

&lt;figure&gt;
 &lt;figcaption&gt;The filtered window&lt;/figcaption&gt;
 &lt;object data=&quot;/assets/tutorials/praat_pitch/figures/fig3.svg&quot;&gt;
  &lt;img src=&quot;/assets/tutorials/praat_pitch/figures/fig3.png&quot; alt=&quot;A Hanning-filtered complex sine wave, with an amplitude close to 0 on
  each end and 1 in the middle&quot; /&gt;
 &lt;/object&gt;
&lt;/figure&gt;

&lt;p&gt;To detect a sound’s pitch Praat uses autocorrelation, comparing each window with
itself.&lt;/p&gt;

&lt;p&gt;An autocorrelation plot shows the degree to which the compared curves are
related on the Y-axis, and the time lag for each comparison on the X-axis. If
the curve is periodic, then there should be a peak on the autocorrelation curve
when the lag is equal to the original curve’s period.&lt;/p&gt;

&lt;p&gt;The autocorrelation is highest at a time lag of 0, so we need to look for peaks
that are greater than 0 for significant periodicity. However, in this case,
since we are working with a complex sound wave with a loud harmonic, the
autocorrelation curve shows a false peak (red line) before the time lag that we
know is the sound’s actual fundamental frequency (blue line), which is alligned
with a lower peak.&lt;/p&gt;

&lt;figure&gt;
 &lt;figcaption&gt;Normalized autocorrelation of the filtered sound&lt;/figcaption&gt;
 &lt;object data=&quot;/assets/tutorials/praat_pitch/figures/fig4.svg&quot;&gt;
  &lt;img src=&quot;/assets/tutorials/praat_pitch/figures/fig4.png&quot; alt=&quot;An autocorrelation function, showing a series of peaks with decreasing
  size. A red line marks the top of the second (on sample 157), and a blue line
  marks the top of the third (on sample 316), which is lower. The fourth peak,
  roughly half-way through the curve, is the last 1 that is plain to see&quot; /&gt;
 &lt;/object&gt;
&lt;/figure&gt;

&lt;p&gt;In order to correct for this, we need to divide the filtered signal by the
normalized autocorrelation curve of the windowing function.&lt;/p&gt;

&lt;figure&gt;
 &lt;figcaption&gt;Normalized autocorrelation of the window function&lt;/figcaption&gt;
 &lt;object data=&quot;/assets/tutorials/praat_pitch/figures/fig5.svg&quot;&gt;
  &lt;img src=&quot;/assets/tutorials/praat_pitch/figures/fig5.png&quot; alt=&quot;Half of a bell curve, starting from 1 and curving downwards to the right,
  asymptotically approaching 0 in the end&quot; /&gt;
 &lt;/object&gt;
&lt;/figure&gt;

&lt;p&gt;The result is an estimate of the autocorrelation of the original signal, which
is both robust and better suited for the analysis of speech signals than
previous methods used. Note that this estimate gets increasingly unreliable
after roughly half the length of the analysis window
(&lt;a href=&quot;#boersma1993&quot;&gt;Boersma, 1993&lt;/a&gt;).&lt;/p&gt;

&lt;figure&gt;
 &lt;figcaption&gt;Estimated autocorrelation of the original signal&lt;/figcaption&gt;
 &lt;object data=&quot;/assets/tutorials/praat_pitch/figures/fig6.svg&quot;&gt;
  &lt;img src=&quot;/assets/tutorials/praat_pitch/figures/fig6.png&quot; alt=&quot;Three cycles of a sinusoid wave, half the length of the ones shown
  before, starting on a peak at a magnitude of 1. The second peak is slightly
  lower than the first. The third peak, which is slightly higher than the
  second, is marked with a blue line on sample 316&quot; /&gt;
 &lt;/object&gt;
&lt;/figure&gt;

&lt;p&gt;And by finding the maximum at a time lag &amp;gt; 0 in this estimated curve, we can
calculate the pitch of the original signal converting from samples to Hz.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; f_0 = \frac{1}{lag_{max} / f_s} &lt;/script&gt;

&lt;noscript&gt;
  &lt;pre&gt;&lt;code&gt;f_0 = 1 / (lag / f_s)
&lt;/code&gt;&lt;/pre&gt;
&lt;/noscript&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; (2015/10/03): This page, which was originally written as notes to
myself, is by far the most popular page in this site. So I feel obligated to
clarify that this article covers only one improvement that can be done to the
use of the autocorrelation function for pitch detection. More robust algorithms,
such as the one actually implemented in Praat, make use of other corrections,
such as pathfinding to ignore sudden changes in f0 that are impossible for the
human vocal tract.&lt;/p&gt;

&lt;aside class=&quot;rem&quot;&gt;
  &lt;p&gt;All figures in this page were generated with &lt;a href=&quot;http://www.r-project.org/&quot;&gt;R&lt;/a&gt; with the commands that can be
found in &lt;a href=&quot;/assets/tutorials/praat_pitch/scripts/figures.R&quot;&gt;this file&lt;/a&gt;.
Feel free to look at the definitions of each curve and to modify it for your own
ends.&lt;/p&gt;
&lt;/aside&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li id=&quot;boersma1993&quot; class=&quot;reference&quot;&gt;Boersma, P. (1993) &lt;a href=&quot;http://www.fon.hum.uva.nl/paul/papers/Proceedings_1993.pdf&quot;&gt;Acurate short-term analysis of the fundamental frequency
  and the harmonics-to-noise ratio of a sampled sound.&lt;/a&gt; IFA
  Proceedings 17: 97-110&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://jjatria.github.io/2012/01/15/pitch-in-praat</link>
                <guid>http://jjatria.github.io/2012/01/15/pitch-in-praat</guid>
                <pubDate>Sun, 15 Jan 2012 00:00:00 +0000</pubDate>
        </item>


</channel>
</rss>
